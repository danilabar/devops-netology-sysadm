## Задача 1

Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её 
нужно прервать. 

Вы как инженер поддержки решили произвести данную операцию:
- напишите список операций, которые вы будете производить для остановки запроса пользователя
- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

### Ответ

- `db.currentOp()` - получу документ, содержащий информацию о выполняемых операциях для экземпляра базы данных
- `db.killOp(opid)` - завершу операцию
- В качестве решения проблемы с долгими запросами можно построить или перестроить соответсвующий индекс

## Задача 2

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и
увеличивается пропорционально количеству реплик сервиса. 

При масштабировании сервиса до N реплик вы увидели, что:
- сначала рост отношения записанных значений к истекшим
- Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?

### Ответ

- Судя по документации возникает ситуация когда в базе данных есть много ключей, срок действия которых истекает в одну и ту же секунду, 
и они составляют не менее 25% текущей совокупности ключей с установленным сроком действия, что может приводить к блокировкам.
 
## Задача 3

Перед выполнением задания познакомьтесь с документацией по [Common Mysql errors](https://dev.mysql.com/doc/refman/8.0/en/common-errors.html).

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения данной проблемы вы можете предложить?

### Ответ

- Документация говорит о том, что необходимо проверить состояние сети. Ещё возможно запрос стал очень большим и 
можно увеличить `net_read_timeout` со значения по умолчанию 30 секунд до 60 секунд или дольше.
- Можно изучить запрос с помощью `EXPLAIN` и оптимизировать его в т.ч. создать индексы и/или увеличить ОЗУ для сервера

## Задача 4

Перед выполнением задания ознакомтесь со статьей [Common PostgreSQL errors](https://www.percona.com/blog/2020/06/05/10-common-postgresql-errors/) из блога Percona.

Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?

Как бы вы решили данную проблему?

### Ответ

- Когда возникает нехватка памяти, происходит вызов `OOM killer` который прерывает процесс PostgreSQL.
- В качестве решения опять же можно изучить запрос с помощью `EXPLAIN` и оптимизировать его в т.ч. создать 
индексы и/или увеличить ОЗУ для сервера

#### Замечание
- В качестве решения опять же можно изучить запрос с помощью EXPLAIN и оптимизировать его в т.ч. создать индексы и/или увеличить ОЗУ для сервера
эксплейн вам скорее поможет снять нагрузку по cpu и диску, никак по памяти он не повлияет, даже если вы триллиард индексов построите объем данных при выборке будет прежней.
просто обкидаться железом у вас не получиться, железо это деньги, и не всегда есть тех возможность просто поставить одну две плашки, все решается проще в разы, расскажите мне как.
конкретные шаги, что, где, зачем? и будет зачет

#### Доработка

- Исходя из [документации](https://www.postgresql.org/docs/current/kernel-resources.html#LINUX-MEMORY-OVERCOMMIT) PG есть несколько вариантов решения:
  - Увеличить файл подкачки - не думаю, что это ожидаемый вариант в качестве решения
  - Если в OOM виноват сам PG, тогда в его конфигурации можно снизить значение параметров связанных с памятью, 
  в частности `shared_buffers`, `work_mem`, и `hash_mem_multiplier`. Ещё может помочь уменьшение `max_connections` и использование балансировщика для подключений
  - Со стороны ОС можно изменить поведение ядра, что бы не происходил "overcommit" памяти, это значительно снизит вероятность возникновения OOM, 
  выбрав режим в котором ядро не будет резервировать больше памяти, чем указано в параметре overcommit_ratio
    ```bash
    sysctl -w vm.overcommit_memory = 2 
    ```
    или разместить эквивалентную запись в `/etc/sysctl.conf`
  - Есть еще один параметр ядра `oom_score_adj` отвечающий за оценку OOM-Killer-а какой процесс следует завершить. 
  Можно указать большое отрицательное значение, что бы снизить шансы на завершение процесса postmaster
    ```bash
    echo -1000 > /proc/self/oom_score_adj
    ```
    Дополнительно нужно установить эти переменные среды в сценарии запуска перед вызовом postmaster
    ```bash
    export PG_OOM_ADJUST_FILE=/proc/self/oom_score_adj
    export PG_OOM_ADJUST_VALUE=0
    ```
    Эти настройки приведут к тому, что дочерние процессы postmaster будут выполняться с нулевой корректировкой обычной
    оценки OOM, так что OOM-Killer по-прежнему сможет нацеливаться на них при необходимости. 
    Если не установить `PG_OOM_ADJUST_FILE`, дочерние процессы будут работать с той же корректировкой оценки OOM, что и postmaster, 
    и тогда теряется смысл приоритета для postmaster

#### Замечание 2

- Данила, последний шанс и не зачет. Зачем вы лезете тюнить ядро? Как оно поможет вам не падать по памяти постгресу? 
Потребление памяти постгресом там не регулируется это подсказка (я уже устал проверять одну и ту же списанную работу), у вас трудности с пониманием материала?

#### Доработка 2

- Я бы не назвал списыванием 6 часов чтения документации и интернетов, максимум списывание из документации.
- Потребление памяти PG как и писал выше можно регулировать параметрами в postgresql.conf  
  - `shared_buffers` - общий буфер сервера, его следует установить в размере 25% от объёма RAM, если RAM на сервере менее 
  1Гб следует понизить значение чтобы оставить достаточно места ОС. Данный некорректно настроенный параметр может служить причиной OOM. 
  `shared_buffers` думаю основной параметр, но есть и другие, такие как `work_mem`, `max_wal_size`, `temp_buffers`,
  `maintenance_work_mem`, `max_stack_depth` и пр. которые так же следует настроить в зависимости от ресурсов хоста, размера БД, количества соединений и сложности запросов
  - Другой информации я не нашёл

